import numpy as np

def filter_relevant_data(X_train, y_train, X_test, y_test):
    """
    Filters the dataset to keep only the samples corresponding to the digits 1 and 5.

    :param X_train: Training data (numpy array of shape (n_samples_train, n_features))
    :param y_train: Training labels (numpy array of shape (n_samples_train,))
    :param X_test: Test data (numpy array of shape (n_samples_test, n_features))
    :param y_test: Test labels (numpy array of shape (n_samples_test,))
    :return: X_train_f, y_train_f, X_test_f, y_test_f: Filtered training and test sets
             containing only samples where the labels are 1 or 5.
    """
    # Filter the training data for labels 1 and 5
    train_filter = np.isin(y_train, [1, 5])
    X_train_f = X_train[train_filter]
    y_train_f = y_train[train_filter]

    # Filter the test data for labels 1 and 5
    test_filter = np.isin(y_test, [1, 5])
    X_test_f = X_test[test_filter]
    y_test_f = y_test[test_filter]

    # Return the filtered data
    return X_train_f, y_train_f, X_test_f, y_test_f

# Example usage:
# Assuming X_train, y_train, X_test, and y_test are already defined
X_train_f, y_train_f, X_test_f, y_test_f = filter_relevant_data(X_train, y_train, X_test, y_test)

# Checking the shapes of the filtered datasets
print(f"Filtered X_train shape: {X_train_f.shape}")
print(f"Filtered y_train shape: {y_train_f.shape}")
print(f"Filtered X_test shape: {X_test_f.shape}")
print(f"Filtered y_test shape: {y_test_f.shape}")
